# Summa V2: Polynomial Interpolation Approach

## Motivation

[Summa V1](https://github.com/summa-dev/summa-solvency/releases/tag/merkle_sum_tree_v1.1.1) was using a Merkle sum tree (MST) as the main data structure and a cryptographic commitment. MST that has $n$ leaves involves $2n-1$ hashing operations, making it computationally demanding. Additionally, the MST inclusion proofs in Summa V1 have to be wrapped into a ZK-SNARK, making it infeasible to generate all of them at once for the entire user base of the Custodian (~100M users).

## Univariate Grand Sum Calculation

The grand total of all the Custodian's $n$ user cryptocurrency balances is the Custodian's liabilities $S$. Summa V2 is using a property of the _sum of all roots of unity in a finite field_ being _equal to zero_ to find the liabilities. This property allows to efficiently calculate the grand sum of univariate polynomial evaluations. Summa V2 takes advantage of that by interpolating the user balances into a univariate polynomial in a special way. The resulting proof of solvency protocol has the following steps:

1. construct a polynomial of degree $d = n - 1$ that interpolates the points $(\omega^i, b_i)$ where $i \in 0..n-1$ is the user index, $\omega^i$ is the power of an $n$-th primitive root of unity ($x$ value), and $b_i$ is the $i$-th user balance value ($y$ value);
2. multiply the constant term $a_0$ of the polynomial by $n$ to obtain the grand sum:
   $\begin{equation}\boxed{S = a_0n= \sum_{i=0}^{n-1}b_i};\end{equation}$
3. use a polynomial commitment scheme to provide opening proofs to the individual users and a public $a_0$ opening at $x=0$.

Please refer to the [article](https://hackmd.io/@summa/BkglBWsDp) for the detailed description of the algorithm.

## Algorithm Implementation

Halo2 allows to efficiently implement the described algorithm for the following reasons:

- the advice columns in Halo2 are interpolated as polynomials, and the $x$ values are the powers of a primitive root of unity;
- Halo2 is internally using a KZG polynomial commitment scheme;
- the use of a ZK-SNARK allows to additionally constrain the balance values, namely, perform the range check.

The algorithm works as follows:

1. Assign all the user balances to an unblinded advice column of the [circuit](../prover/src/circuits/univariate_grand_sum.rs). The unblinded advice column is a special kind of advice column without the random values (blinding factors) added at the bottom. The constant term of such polynomial correctly yields the grand total of user balances according to (1) because the polynomial only interpolates the user balances but not the blinding factors (as in the case with a normal advice column).
2. Assign the user IDs (e.g., hashes of user emails) to another (normal) advice column.
3. Generate the ZK-SNARK proof for the circuit, effectively interpolating the balance values into a polynomial and performing a KZG commitment to this polynomial.
4. Perform a KZG opening proof of the polynomial at $x=0$ and publicly reveal the constant term $a_0$ of the polynomial. The public can then calculate the liabilities by multiplying the $a_0$ by $d + 1$ where $d$ is the polynomial degree.
5. Privately provide to each user a KZG proof of the corresponding user opening (namely, the openings of the user ID and balance polynomials). Cross-checking the balance opening and the user ID opening $\omega^i$ value ensures that no malicious Custodian can provide the same balance opening to multiple users with the identical balance value.

## Usage

To build, test and print the circuits, execute

```
cargo build
cargo test --release --features dev-graph
```

To generate the solidity verifier that can verify the SNARK proof, execute the following command:

```
cargo run --bin generate_verifier
```

This process will generate the verifier, `SnarkVerifier.sol`, which will be located in `../contracts/src`.

To generate commitments and proofs with the sample data located in `entry_16.csv` at `../csv/`, execute:

```
cargo run --bin generate_commitment_and_proofs
```

This script will generate `commitment_solidity_calldata.json` and `inclusion_proof_solidity_calldata.json` in the `prover/bin`.<br>
These two JSON files will be used for testing in the `contracts`.

## Documentation

The documentation for the circuits can be generated by running

```
cargo doc --no-deps --open
```

## Powers of Tau Trusted Setup

For testing purposes, it's not necessary to download the `ptau` file. The `generate_setup_artifacts` function can manage this by generating a new setup from a randomly generated value. This automated generation process is intended for testing and development convenience, and it should not be used in production.
For real-world situations, you must provide the path of a specific `ptau` file to the `generate_setup_artifacts`. The circuit will use the randomness from the given file. You can find an example that initializes a `Snapshot` instance [here](https://github.com/summa-dev/summa-solvency/blob/11d4fce5d18f6175804aa792fc9fc5ac27bf5c00/backend/src/apis/snapshot.rs#L115-L116) in the backend.

## Benchmarks

The following benchmarks are available in the `kzg` module:

- `range_check_proof`: the zk-SNARK proof generation time of the polynomial interpolation of user balances with range check;
- `opening_grand_sum`: the time to generate the KZG opening proof of the grand sum of user balances;
- `opening_user`: the time to generate the KZG opening proof of a single user inclusion;
- `calculate_h`: the time to calculate the h(X) for the amortized KZG approach;
- `amortized_opening_all`: the time to generate open proofs for all 2^K user inclusions using the amortized approach;
- `amortized_opening_user`: the time to generate the KZG opening proof of a single user inclusion using the precomputed h(x) from the amortized approach;
- `verifying_grand_sum`: the time to verify the KZG opening proof of the grand sum of user balances;
- `verifying_user`: the time to verify the KZG opening proof of a single user inclusion.

To run the benchmarks with the default full configuration of the circuit (range check enabled), use the following command:

```shell
cargo bench
```

To run the quick benchmarks with the range check disabled (K=9..12), use the following command:

```shell
cargo bench --features "no_range_check"
```

## Chunked Univariate Grand Sum Example

the following technique is proposed to further improve the performance of the univariate grand sum version of Summa:

1. Split the user base into chunks;
2. Generate the zkSNARK range proof for all the users of each chunk (one proof per chunk) alongside with the advice polynomials;
3. Generate the proofs of inclusion of a user into a specific chunk;
4. Prove the grand total across the chunks by performing the following:
   1. Add together the chunk polynomials generated in step 2;
   2. Add their corresponding KZG commitments together using the homomorphic property of the KZG commitment;
   3. Generate the opening proof of the grand sum for the resulting polynomial from step 4.1 against the commitment from step 4.3

Step 4 of the algorithm establishes the relation between the chunks containing individual user liabilities and the grand sum of all user liabilities. The proof of inclusion generation in step 3 should be carried out using the amortized KZG approach in the similar fashion as in the non-chunked version of Summa.

The proof of concept implementation of the suggested approach can be found in the [example file](prover/examples/chunked_univariate_grand_sum.rs). To execute the example, use the command:

```shell
cargo run --release --example chunked_univariate_grand_sum
```
